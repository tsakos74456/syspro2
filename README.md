Εργασία 2
Η 2η εργασία δεν πήγε και τόσο καλά όσο η 1η. Παρόλα αυτά κατάφερα να βγάλω ένα αρκετά μεγάλο κομμάτι της. Σας ζητάω συγγνώμη εκ των προτέρων καθώς σε κάποια σημεία είνια δυσνόητος και δεν έχει όσα σχόλια θα ήθελα να έχει αλλά λόγω υπερβολικού φόρτου εργασίας και από άλλα μαθήματα έκανα ότι μπορούσα. 

lib: στον φάκελο lib υπάρχουν υλοποιήση queue και list που χρησιμοποιήθηκαν ως αποθηκετικά μέσα. Το threadpool είναι με queue ενώ το sync_info_mem_store είναι με list περισσότερες πληροφόρίες για τις συναρτήσεις μπορείτε να βρείτε στα .h αρχεία τους.

Ακολουθεί η λογική του κώδικά μου, υπάρχουν σχολία και στα .c αρχεία και τι κάνει η κάθε συνάρτηση εξηγείται και στα αντίστοιχα .h

nfs_console:
H κονσόλα είναι στην ίδια λογική με την 1η εργασία ως προς τη χρήση αυτό που αλλάζει είναι η επικοινωνία. Συνδεέται μέσω socket(non-block) με τον manager και στη συνέχεια περιμένει και  διαβάζει από τον χρήστη τις εντολές add, cancel, shutdown τις προωθεί στον manager μέσω του socket στη συνέχεια παίρνει τις απαντήσεις από τον manager και τις εκτυπώνει στην οθόνη και στο console-logfile. Όταν λάβει το τελευταίο μύνημα που δίνει ο manager δηλαδή "Manager shutdown complete." κλείνει. Στο config file καταγράφονται οι εντολές και όλες τις απαντήσεις του manager.

nfs_client:
O nfs_client συνδεεται δημιουργεί ο ίδιος το  αρχικό socket και περιμένει συνδέσεις από τον manager. Όταν αυτός συνδεθεί διαβάζει την οδηγία LIST, PUSH, PULL και κάνει ότι λέει η εκφώνηση ότι πρέπει να κάνει. Στο LISΤ παραθέτει τα περιεχόμενα του folder και στο τέλος έχει μια τελέια. Στο Pull στέλνει το μέγεθος και στη συνέχεια το περιεχόμενο του αρχείου που δέχεται όσο μεγάλο και αν είναι αυτό σε διαφορετικά chunk. Στο push γράφει στο αρχείο αυτά που δέχεται από ένα worker thread του manager. Αυτό που κατάλαβα από την εκφώνηση και έπραξα στη λογική του κώδικα μου για το Push είναι ότι όταν το chunk size = -1 τότε κάνει create το αρχείο και truncate (το αντίστοιχο flag) όταν είναι = 0 τότε τελειώσαμε και το κλείνουμε και όταν είναι > 0  απλά κάνουμε append. Στα μυνήματα που δέχεται όταν το chunk size = -1 ή > 0 τότε αυτά ακολοθούνται και από data ενώ όταν είναι = 0 δεν ακολοθούνται για αυτό κάνω τα αντίστοιχα write() στις αντίστοιχες περιπτώσεις. Βασισμένος σε αυτή την λογική το έσπαγα και σε chunk ακόμα και όταν τα αρχεία η΄ταν πιο μεγάλα. Επίσης κάτι που πρόσθεσα είναι στο target ip να δημιουργώ τον φάκελο αν δεν υπάρχει μόνο όμως τον "last" όχι όλους αναδρομικά. Π.χ. αν το path ήταν home/users/sdi/testing και δεν υπήρχε ο φάκελος testing τον δημιουργώ(mkdir).
Το μόνο που λείπει η διαχείρηση των σφαλμάτων από τα opendir(), open() δηλαδή αν τα αρχεία δεν υπάρχουν μέσα σε αυτά τα sources ή target ανάλογα δε θα δουλεύει. Αυτά που θα δοθούν θα πρέπει να υπάρχουν. Τα sockets του nfs_client είναι blocked οπότε για να προχωρήσει πρέπεινα διαβάσει κάτι. Επιπλέον αμα δεχθούν εντολή SHUT τερματίζουν (δική μ παραδοχή).

nfs_manager:
Ο nfs_manager διαβάζει τα flags, ανοίγει το socket επικοινωνίας με το console(non-block) και δημιουργεί το man_logfile. Στη συνέχεια δημιουργεί τις δομές(το queue είναι όσο το όρισμα στο buffer size), τον admin μια δομή που περιέχει το threadpool τα worker threads και Mutex ,cond για να χρησημοποίουν τα threads. Στη συνέχεια δημιουργεί όσο είναι το worker limit και αυτά βλέπουν το queue και όταν μπαίνει κάποια διεργασία την αναλαμβάνουν. Τα worker threads αναλαμβάνουν τα push pull και list. Ένα κάνει το list και για κάθε αρχείο που διαβάζει δημιουργει ένα threadpool info που είναι ουσιαστικά η διεργασία. Μετά ξυπνάει(signal/broadcast) κάποιο άλλο worker και το αναλμβάνει άλλος το pull - push. To worker thread που αναλμβάνει το 2ο κομμάτι στέλνει PULL στο source, παίρνει τα data φτιάχνει το "πακέτο", τα στέλνει μέσω push στο target και ο client είναι υπεύθηνος να τα αποθηκεύσει. Αυτή είναι η βασική δουλεία των workers όπου μπάινουν se wait όταν θέλουν να βάλουν κάτι στο buffer και αυτό είναι γεμάτο ή όταν αυτό είναι άδειο. Μετά το main thread o manager δλδ αναλαμβάνει επικοινωνία με console και ότι εντολή του δώσει το console κάνει την αντίστοιχη δουλειά και κάποιες φορές ενημερώνει(shutdown, cancel, περιπτώσεις του add). Όταν πάει add απλά κάνει parsing την εντολή τη σπάει στα κομμάτια που θέλει και στη συνέχεια δημιουργεί μια δουλεία list που την αναλαμβάνει κάποιο worker thread. Όταν δέχεται το cancel απλά βγάζει από το threadpool (queue) αν υπάρχει κάποιο job που σχετίζεται με αυτό το source. Στο shutdown του manager ξεκινάει περιμένει να τελειώσουν όλα τα worker threads στη συνέχεια στέλνει στα clients να κλείσουν και μετά τερματίζει ελευθερώνοντας threads και fre, destroy τα ανάλογα. Επιπλέον σε κάποιες εντολές(shutdown, cancel και add κάποιες περιπτώσεις) ενημερώνω κονσόλα, οθόνη και γράφω στο manager log.


Περισσότερες πληροφόριες για τις συναρτήσεις και τι κάνουν υπάρχουν στα .h αρχέια.

Οδηγίες για να τρέξει:
με την εντολή make all κανουν όλα compile kai separate.
μετά κανείς μπορεί να κάνει make nfs_manager, make nfs_console και make nfs_client για να μεταγλωττίσει τα αρχεία ξεχωριστά για τον εκάτοτε λόγο
υπάρχει και το make run_... για τον εκαστοτε manager, client, console αλλά εκεί αναλόγως θα πρέπει να κάνετε αλλαγές στα args. Η IP που έχω βάλει εγώ είναι το 127.0.0.κάτι για να επικοινωνεί με τον υπολογιστή που τα τρέχουμε όλα για εξυπηρέτηση, μπορεί να αλλαχθεί αυτό προφανώς
επιπλέον υπάρχουν τα αντιστοιχα make valgrind που μπορεί κανείς να τα τρέξει με valgrind και να διαπιστώσει κανείς οτί δεν υπάρχουν leaks
ΠΡΟΣΟΧΗ: για να τρεέξει όταν ο θα πρέπει να γίνει με τον εξής τρόπο πρώτα εκτελούμε τα clients για να ανοίξουν τα sockets και μετα manager console με αυτή τη σειρά διαφορετικά το ένα άκρο του socket θα δημιουργηθεί χωρίς να έιναι από την άλλη μερία αυτός που το δημιουργεί. Επομένως θα προσπαθεί αν συνδεθεί σε ενα socket που δεν υπάρχει. Οπότε με τη σειρά που λέω παραπάνω.
Για δοκιμές υπάρχουν κάποια μικρά αρχεία κα ένα μεγάλο που δε χωράει σε ενα chunk στο testing απλά θα πρέπει να συμπληρώσει κανέις τα αντίστοιχα paths στο config ή να τα περάσει μέσω add αλλά όχι αυτά που υπάρχου στο config αλλά τα αντίστοιχα δικά του.
Τελος υπάρχει και το make clean_... για το κάθε εκτελέσιμο για καθαρισμό .ο, .d και εκτελέσιμων αρχείων αλλα το make clean είναι γενικά για όλα μαζί.